# Serena MCP によるトークン効率化ガイド

このドキュメントでは，Serena MCP ツールを使用したコード探索がトークン消費をどのように削減するかを説明する．

## 概要

Serena は Language Server Protocol (LSP) を活用したシンボリックコード解析ツールである．
従来の Grep/Read ベースの探索と比較して，特に以下のタスクでトークン効率が向上する:

- シンボル参照の追跡
- クラス/関数の構造理解
- リファクタリング影響範囲の特定

## 実験結果

### テストケース1: コード構造理解タスク

**タスク**: Network クラスと Loss クラスの構造・関係性を調査

| 項目 | Serena | 標準ツール | 差分 |
|------|--------|-----------|------|
| Messages | 40.1k | 55.7k | **-15.6k (-28%)** |
| MCP tools 定義 | 8.0k | 0.3k | +7.7k |
| **合計** | **67k** | **74k** | **-7k (-9%)** |

### テストケース2: 変更影響範囲調査タスク

**タスク**: `SVGBoardRenderer` クラスのインターフェース変更時の影響範囲を特定

| 項目 | Serena | 標準ツール | 差分 |
|------|--------|-----------|------|
| Messages | 15.2k | 8.8k* | - |
| MCP tools 定義 | 8.0k | 0k | +8.0k |
| サブエージェント | 0k | 69.6k | -69.6k |
| **合計** | **44k** | **78k** | **-34k (-44%)** |

*標準方式は Explore サブエージェントに処理を委譲

## 効率化のメカニズム

### 1. `find_referencing_symbols` による参照追跡

従来の方式:
```
Grep "ClassName" → 複数ファイルヒット → 各ファイルを Read → コンテキスト解析
```

Serena 方式:
```
find_referencing_symbols("ClassName") → 参照箇所とコンテキストを直接取得
```

LSP が内部でシンボル解決を行うため，文字列マッチングの誤検出がなく，必要な情報のみを取得できる．

### 2. `get_symbols_overview` による構造把握

従来の方式:
```
Read file.py (全体) → 手動でクラス/メソッド構造を解析
```

Serena 方式:
```
get_symbols_overview("file.py") → シンボル一覧のみ取得（本体なし）
```

ファイル全体を読み込まずにシンボル構造を把握できる．

### 3. `find_symbol` による選択的読み込み

従来の方式:
```
Read file.py → 目的のクラス/メソッドを探す
```

Serena 方式:
```
find_symbol("ClassName/method_name", include_body=True) → 該当シンボルのみ取得
```

## 推奨使用パターン

### Serena が効果的なタスク

| タスク | 推奨ツール | 理由 |
|--------|-----------|------|
| シンボル参照追跡 | `find_referencing_symbols` | 直接参照を取得，Grep より正確 |
| クラス構造理解 | `get_symbols_overview` | ファイル全体を読まずに概要把握 |
| メソッド実装確認 | `find_symbol` with `include_body=True` | 必要なシンボルのみ取得 |
| リファクタリング影響調査 | `find_referencing_symbols` | 変更箇所の網羅的特定 |

### 標準ツールが適切なタスク

| タスク | 推奨ツール | 理由 |
|--------|-----------|------|
| 広範囲テキスト検索 | Grep | 正規表現による柔軟な検索 |
| 設定ファイル検索 | Glob + Read | 非コードファイルの探索 |
| 単一ファイル確認 | Read | シンプルで直接的 |
| 複雑な調査タスク | Task/Explore | サブエージェントによる自律的探索 |

## ベストプラクティス

### 1. 段階的な情報取得

```
1. get_symbols_overview → ファイル構造を把握
2. find_symbol (include_body=False) → 候補シンボルを特定
3. find_symbol (include_body=True) → 必要なシンボルのみ詳細取得
```

### 2. 参照追跡の活用

インターフェース変更時:
```
1. find_symbol でターゲットシンボルを特定
2. find_referencing_symbols で全参照箇所を取得
3. 影響範囲をリスト化
```

### 3. MCP tools 定義コストの考慮

Serena ツール定義には約 8k トークンの固定コストがある．
以下の場合は標準ツールの方が効率的な場合がある:

- 単一ファイルの簡単な確認
- 1-2 回の Grep で完結する検索
- 非コードファイル（YAML，JSON など）の探索

## トークン効率の目安

| 調査の複雑さ | Serena 効率 | 備考 |
|-------------|-------------|------|
| 単純（1-2 ファイル） | 同等〜やや非効率 | 固定コスト 8k が影響 |
| 中程度（3-5 ファイル） | **10-30% 効率的** | シンボル解析の効果が出始める |
| 複雑（参照追跡あり） | **30-50% 効率的** | find_referencing_symbols が威力を発揮 |

## 関連ドキュメント

- [Architecture](./architecture.md) - プロジェクト全体のアーキテクチャ
- [Code Quality](./code-quality.md) - コード品質ガイドライン
